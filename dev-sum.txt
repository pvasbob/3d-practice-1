React Hooks
│
├── 1. useState
│     ├── Purpose: store reactive values that update UI
│     ├── Changing state triggers re-render
│     ├── Example:
│     │     const [count, setCount] = useState(0);
│     │     setCount(1); // re-renders component
│     └── React uses latest state on each render
│
├── 2. useEffect
│     ├── Purpose: run side effects after render
│     ├── useEffect itself DOES NOT re-render
│     ├── Effect re-runs when dependency array changes
│     ├── Example:
│     │     useEffect(() => {
│     │       console.log("runs when count changes");
│     │     }, [count]);
│     └── If effect calls setState → THEN re-render happens
│
└── 3. useRef
      ├── Purpose: persistent mutable storage (no re-render)
      ├── behaves like a “static variable”
      ├── .current is the only property
      ├── Example:
      │     const count = useRef(0);
      │     count.current++;  // persists, no re-render
      ├── Often holds:
      │     ├── DOM nodes
      │     ├── timers
      │     ├── previous values
      │     └── external objects (gsap timeline, audio, video)
      └── Why no re-render?
            Because React does NOT track ref.current changes.






DOM Refs
│
├── 1. What is a “DOM node”?
│     └── The actual HTML element object created in the browser.
│
├── 2. Why videoRef.current.play() works?
│     ├── <video> has built-in .play() and .pause() methods.
│     ├── videoRef.current becomes the <video> DOM element.
│     └── Example:
│           const videoRef = useRef(null);
│           <video ref={videoRef} />
│           videoRef.current.play();
│
├── 3. Callback refs
│     ├── Also receive the DOM element as parameter
│     ├── Example:
│     │     <div ref={el => console.log(el)}></div>
│     └── “el” is NOT a keyword — it’s just the element passed in.
│
└── 4. What can go inside ref={} ?
      ├── a ref object
      │     <div ref={myRef} />
      └── a callback function
            <div ref={el => myRef.current = el} />



GSAP Targeting
│
├── You can animate via:
│     ├── DOM element (best)
│     │     gsap.to(videoRef.current[i], {...})
│     ├── id selector
│     │     gsap.to("#box", {...})
│     └── class selector
│           gsap.to(".box", {...})
│
├── But selectors are fragile in React because:
│     ├── React may re-create DOM → old selectors point to old nodes
│     ├── strict mode runs effects twice → animation triggers twice
│     ├── ".box" may match extra elements unintentionally
│     ├── order of elements not guaranteed
│     └── timing issues (selector runs before DOM exists)
│
└── Refs are stable:
      ├── exact elements
      ├── always correct order
      ├── never break on re-render
      ├── safe under StrictMode
      └── GSAP prefers real DOM nodes → ref gives them directly





Ref Arrays
│
├── Example:
│     const boxesRef = useRef([]);
│
│     <div ref={el => boxesRef.current[0] = el}></div>
│     <div ref={el => boxesRef.current[1] = el}></div>
│
├── GSAP using stagger:
│     useEffect(() => {
│       gsap.to(boxesRef.current, { y: -50, stagger: 0.2 });
│     }, []);
│
└── This is stable + React-correct way.




className Animation (".box")
│
├── Works but fragile in React:
│     gsap.to(".box", { y: -50, stagger: 0.2 });
│
├── Problems:
│     ├── Might select unintended elements
│     ├── React DOM order can change
│     ├── Non-React elements may be selected
│     ├── Selectors may run before DOM exists
│     └── Strict mode duplicates the effect
│
└── Using refs avoids all of this.




Layout
│
├── Meaning:
│     The position and size of an element on the page.
│
├── Example properties:
│     ├── x, y position
│     ├── width, height
│     ├── top, left, right, bottom
│
├── Only DOM gives layout info:
│     element.getBoundingClientRect()
│
└── React CANNOT give you layout values.




Vanilla HTML/JS
│
├── “Vanilla” means:
│     pure HTML
│     pure CSS
│     pure JavaScript
│
├── No frameworks:
│     ❌ no React
│     ❌ no Vue
│     ❌ no Angular
│
└── Example:
      const box = document.querySelector(".box");
      box.style.opacity = 0;


useState → reactive data, causes re-render
useEffect → runs after render, re-runs when dependencies change
useRef → persistent container, does NOT cause re-render, ideal for DOM




GSAP & ScrollTrigger Q&A

ScrollTrigger watches element existence?

Q: ScrollTrigger does not continuously watch the element, so does it watch if an element with id='video' exists?

A: No. ScrollTrigger only watches scroll position. The element must exist initially for ScrollTrigger to measure it. It does not detect dynamic creation; you would need to call .refresh() if elements appear later.

onComplete behavior in zero-duration animation

Q: In gsap.to() with no properties to animate, does onComplete fire immediately?

A: Yes. onComplete fires only after the animation finishes. Zero-duration animation finishes immediately, so onComplete runs instantly.

ScrollTrigger initial measurement

Q: When does ScrollTrigger measure positions the first time?

A: It measures immediately upon creation, which is often before images load or layout fully stabilizes.

ScrollTrigger.refresh()

Q: Why and when should I call ScrollTrigger.refresh()?

A: Call it whenever layout changes after ScrollTrigger creation (e.g., images load, dynamic content, font load, element resize). Refresh recalculates offsets, heights, start/end positions.

Effect of browser refresh

Q: Does browser refresh recalculate positions?

A: Yes. The DOM is reconstructed, and ScrollTrigger initializes again, measuring all positions anew.

Using ScrollTrigger for dynamic layout changes

Q: For drag/move operations, do I need to call ScrollTrigger.refresh() every time?

A: Only if the element moves. Using trigger.update() or throttling refresh is more efficient than calling full refresh continuously.

GSAP config property order

Q: Does the order of x: 100 and scrollTrigger matter?

A: No. GSAP parses the object as a whole. It reads all properties, creates tween and ScrollTrigger instances independently.

ScrollTrigger independence from GSAP animation

Q: Can ScrollTrigger work without GSAP animation?

A: Yes. ScrollTrigger is a plugin. It can be used independently to fire callbacks based on scroll positions.

Plugin import necessity

Q: Is importing ScrollTrigger necessary?

A: Yes. You must import and register it to guarantee behavior:

import ScrollTrigger from "gsap/ScrollTrigger";
gsap.registerPlugin(ScrollTrigger);

Note: In some environments or templates, ScrollTrigger may be loaded globally or bundled, making explicit import unnecessary.

ScrollTrigger execution vs animation execution

Q: Does ScrollTrigger execute before the tween?

A: Yes. ScrollTrigger monitors scroll and decides when the tween should start. The tween only runs after ScrollTrigger triggers it.

ScrollTrigger as an event listener

Q: Can ScrollTrigger be used as a self-designed scroll-based event listener?

A: Yes. ScrollTrigger can be used purely with callbacks (onEnter, onLeave, etc.) without animation.

Performance considerations with drag

Q: Dragging an element and calling refresh each time — is it costly?

A: Yes. Full ScrollTrigger.refresh() every frame is CPU intensive. Alternatives:

Use trigger.update() for the specific instance

Debounce/throttle refresh

Use Draggable onDrag callbacks and manual position checks instead of ScrollTrigger

Tree Representation (conceptual):

GSAP + ScrollTrigger ├─ Tween Properties (x, y, opacity, etc.) ├─ scrollTrigger: {} │ ├─ Measures element position upon creation │ ├─ Monitors scroll position │ ├─ Fires callbacks or controls tween start │ └─ Needs refresh() if layout changes └─ Plugin Import & Registration ├─ import ScrollTrigger from "gsap/ScrollTrigger" └─ gsap.registerPlugin(ScrollTrigger)